{"name":"Func-helper","tagline":"Functional helpers for Java","body":"## Functional helpers for java\r\n\r\n[![Build Status](https://travis-ci.org/BluePyth/func-helper.png?branch=master)](https://travis-ci.org/BluePyth/func-helper)\r\n\r\nThis project is a really simple functional library. It provides only the building blocks that I lacked while working on a project. It is mostly inspired by what I've seen and used in the Scala language.\r\n\r\n## Get it\r\n\r\nFunc-helper is available in my maven repository as snapshots for now (API shouldn't break but you never know. GroupId expected to change for the first stable release).\r\n\r\n```xml\r\n<!-- Repository -->\r\n<repositories>\r\n    <repository>\r\n        <id>bluepyth</id>\r\n        <name>BluePyth Repository</name>\r\n        <url>http://repository.bluepyth.fr/content/repositories/snapshots</url>\r\n\t<snapshots>\r\n\t    <enabled>true</enabled>\r\n\t    <updatePolicy>always</updatePolicy>\r\n\t</snapshots>\r\n    </repository>\r\n</repositories>\r\n\r\n<!-- Dependency -->\r\n<dependency>\r\n    <groupId>fr.bluepyth.java</groupId>\r\n    <artifactId>func-helper</artifactId>\r\n    <version>1.0.0-SNAPSHOT</version>\r\n</dependency>\r\n```\r\n\r\n## Features\r\n\r\n### Functions\r\n\r\nAs building blocks of functional programming, they are present in this library. They are easy to use, but until Java 8, the syntax will look very heavy.\r\n\r\n```java\r\nimport static fr.bluepyth.java.funchelper.function.FunComposer.compose;\r\nimport fr.bluepyth.java.funchelper.function.F1;\r\n\r\n\r\npublic class Functions {\r\n\t\r\n\tF1<Integer, String> intToString = new F1<Integer, String>() {\r\n\t\t@Override\r\n\t\tpublic String apply(Integer input) {\r\n\t\t\treturn String.valueOf(input);\r\n\t\t}\r\n\t};\r\n\t\r\n\tF1<String, Integer> stringToInt = new F1<String, Integer>() {\r\n\t\t@Override\r\n\t\tpublic Integer apply(String input) {\r\n\t\t\treturn Integer.valueOf(input);\r\n\t\t}\r\n\t};\r\n\r\n\tpublic Functions() {\r\n\t\tintToString.apply(2);   // => \"2\"\r\n\t\tstringToInt.apply(\"3\"); // => 3\r\n\t\t\r\n\t\tcompose(intToString, stringToInt).apply(2); // => 2\r\n\t}\r\n}\r\n```\r\n\r\n### Opt\r\n\r\nOption[T] is a very handy structure in Scala. Guava has its own Optional<T>, but I didn't want to depend on any lib. Thus, Opt<T>\r\n\r\n```java\r\nimport static fr.bluepyth.java.funchelper.option.Opt.none;\r\nimport static fr.bluepyth.java.funchelper.option.Opt.toOpt;\r\nimport fr.bluepyth.java.funchelper.function.F1;\r\nimport fr.bluepyth.java.funchelper.option.Opt;\r\n\r\n\r\npublic class Option {\r\n\t\r\n\tF1<Integer, String> intToString = new F1<Integer, String>() {\r\n\t\t@Override\r\n\t\tpublic String apply(Integer input) {\r\n\t\t\treturn String.valueOf(input);\r\n\t\t}\r\n\t};\r\n\t\r\n\tpublic Option() {\r\n\t\t\t\t\r\n\t\tOpt<Integer> intOpt = toOpt(null); // => None\r\n\t\tOpt<Integer> intOpt2 = toOpt(3);   // => Some(3)\r\n\t\t\r\n\t\tOpt<Integer> choose = intOpt.or(intOpt2); // => Some(3)\r\n\t\t\r\n\t\tOpt<String> map = choose.map(intToString); // => Some(\"3\")\r\n\t\t\r\n\t\tmap.isDefined(); // => true\r\n\t\tintOpt.getOrElse(3); // => 3\r\n\t\tintOpt.get(); // => NoSuchElementException\r\n\t\t\r\n\t\tOpt<Integer> noneOpt = none();\r\n\t}\r\n}\r\n```\r\n### IList\r\n\r\nThis construct is an immutable linked list. It is based on the same implementation as Scala's List.\r\n\r\n```java\r\nimport static fr.bluepyth.java.funchelper.Nothing.nothing;\r\nimport static fr.bluepyth.java.funchelper.immutable.IList.list;\r\nimport static fr.bluepyth.java.funchelper.immutable.IList.nil;\r\nimport static fr.bluepyth.java.funchelper.immutable.IList.range;\r\nimport static fr.bluepyth.java.funchelper.immutable.IList.rangeIncl;\r\nimport fr.bluepyth.java.funchelper.Nothing;\r\nimport fr.bluepyth.java.funchelper.function.F1;\r\nimport fr.bluepyth.java.funchelper.function.F2;\r\nimport fr.bluepyth.java.funchelper.immutable.IList;\r\n\r\n\r\npublic class ImmutableList {\r\n\t\r\n\tpublic ImmutableList() {\r\n\t\t\r\n\t\tnil();  // => empty list\r\n\t\tIList<Integer> l = list(1, 2, 3); // => List(1,2,3)\r\n\t\trange(0, 3); // List(0,1,2)\r\n\t\trangeIncl(0, 3); // List(0,1,2,3)\r\n\t\t\r\n\t\tl.get(1); // => 2\r\n\t\tl.head(); // => 1\r\n\t\tl.tail(); // => List(2,3)\r\n\t\tl.isEmpty(); // => false\r\n\t\tl.reverse(); // => List(3,2,1)\r\n\t\tl.mkString(\"-\"); // => 1-2-3\r\n\t\tl.mkString(\"[\", \":\", \"]\"); // => [1:2:3]\r\n\t\tl.prepend(0); // => List(0,1,2,3)\r\n\t\t\r\n\t\tl.map(intToString); // => List(\"1\",\"2\",\"3\")\r\n\t\tl.filter(isOdd); // => List(1,3)\r\n\t\tl.foreach(print); // => prints 1, then 2, then 3\r\n\t\tl.foldLeft(0, sum); // => 6\r\n\t}\r\n\t\r\n\tF1<Integer, String> intToString = new F1<Integer, String>() {\r\n\t\t@Override\r\n\t\tpublic String apply(Integer input) {\r\n\t\t\treturn String.valueOf(input);\r\n\t\t}\r\n\t};\r\n\t\r\n\tF1<Integer, Boolean> isOdd = new F1<Integer, Boolean>() {\r\n\t\t@Override\r\n\t\tpublic Boolean apply(Integer input) {\r\n\t\t\treturn input % 2 == 1;\r\n\t\t}\r\n\t};\r\n\t\r\n\tF1<Integer, Nothing> print = new F1<Integer, Nothing>() {\r\n\t\t@Override\r\n\t\tpublic Nothing apply(Integer input) {\r\n\t\t\tSystem.out.println(input);\r\n\t\t\treturn nothing;\r\n\t\t}\r\n\t};\r\n\t\r\n\tF2<Integer, Integer, Integer> sum = new F2<Integer, Integer, Integer>() {\r\n\t\t@Override\r\n\t\tpublic Integer apply(Integer i1, Integer i2) {\r\n\t\t\treturn i1 + i2;\r\n\t\t}\r\n\t};\r\n}\r\n\r\n```\r\n\r\n### Try\r\n\r\nThis structure allows you to return success or failure information.\r\n\r\n```java\r\nimport static fr.bluepyth.java.funchelper.immutable.IList.list;\r\nimport static fr.bluepyth.java.funchelper.trylike.Try.emptySuccess;\r\nimport static fr.bluepyth.java.funchelper.trylike.Try.failure;\r\nimport static fr.bluepyth.java.funchelper.trylike.Try.success;\r\nimport static fr.bluepyth.java.funchelper.trylike.Try.trySeq;\r\nimport fr.bluepyth.java.funchelper.immutable.IList;\r\nimport fr.bluepyth.java.funchelper.trylike.FTry;\r\nimport fr.bluepyth.java.funchelper.trylike.Try;\r\n\r\n\r\npublic class TryStructure {\r\n\t\r\n\tpublic TryStructure() {\r\n\t\t\r\n\t\temptySuccess(); // => Success<Nothing>(nothing)\r\n\t\tfailure(new Exception()); // => Failure<Exception, Object>\r\n\t\tsuccess(Integer.valueOf(2)); // => Success<Integer>(2)\r\n\t\t\r\n\t\tstrToDouble.apply(\"2.34\"); // => Success<Double>(2.34)\r\n\t\tstrToDouble.apply(\"xxxx\"); // => Failure(NumberFormatException, Double>\r\n\t\t\r\n\t\tstrToDouble.apply(\"2.34\").map(doubleToStr); // => Success<String>(\"2.34\")\r\n\t\t\r\n\t\tIList<Try<Integer>> l = \r\n\t\t\tlist((Try<Integer>) success(1), (Try<Integer>) success(2), (Try<Integer>) success(3));\r\n\t\t\r\n\t\tTry<IList<Integer>> tl = trySeq(l); // => Success(List(1,2,3)) \r\n\t}\r\n\t\r\n\tFTry<String, Double> strToDouble = new FTry<String, Double>() {\r\n\t\t@Override\r\n\t\tpublic Try<Double> apply(String input) {\r\n\t\t\ttry {\r\n\t\t\t\treturn success(Double.valueOf(\"xxx\"));\r\n\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\treturn failure(e);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\t\r\n\tFTry<Double, String> doubleToStr = new FTry<Double, String>() {\r\n\t\t@Override\r\n\t\tpublic Try<String> apply(Double input) {\r\n\t\t\treturn success(input.toString());\r\n\t\t}\r\n\t};\r\n\t\r\n}\r\n```\r\n\r\n## Roadmap\r\n\r\nIf someone else than me is to use this library, I'm open to feedback! Will add whatever I'd like to use in Java.\r\n\r\n## License\r\n\r\nCopyright Romain Sertelon 2013\r\n\r\nThis software is licenced under the Apache Software License v2.0, you can find it in the LICENCE file.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}